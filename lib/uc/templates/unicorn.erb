require 'uc/unicorn/api'
uc = ::Uc::Unicorn::Api.new("<%= config.fetch :event_queue %>")
worker_processes <%= config.fetch :instances %>
working_directory "<%= paths.app_dir %>"
timeout <%= config.fetch :timeout %>
listen "<%= paths.socket %>" , :backlog => <%= config.fetch :queue_size %>
pid "<%= paths.pid_file %>"
stdout_path "<%= paths.stdout_log %>"
stderr_path "<%= paths.stderr_log %>"

ready_wait = <%= config.fetch :ready_wait %>

preload_app true

GC.respond_to?(:copy_on_write_friendly=) and
  GC.copy_on_write_friendly = true

check_client_connection false

before_fork do |server, worker|

  uc.init(server)

  defined?(ActiveRecord::Base) and
    ActiveRecord::Base.connection.disconnect!

  if defined?(Resque)
    Resque.redis.quit
    Rails.logger.info('Disconnected from Redis')
  end

  uc.wait_for_worker_ready(server, worker, ready_wait: ready_wait)
  uc.gradual_shutdown(server, worker)
  sleep 0.3
end

after_fork do |server, worker|
  defined?(ActiveRecord::Base) and
    ActiveRecord::Base.establish_connection
    
  uc.prestart server, worker, url: "<%= config.fetch :prestart_url %>"
  uc.send_worker_ready server, worker, ready_wait: ready_wait
  uc.end_run worker
end

before_exec do |server|
  uc.clean_env
end

if respond_to? :on_exec_fail
  uc = uc
  on_exec_fail do |server|
    puts "runnign asdadad"
    uc.on_exec_fail
    puts "lol"
  end
end
